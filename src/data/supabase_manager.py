"""
Supabase Database Manager for Flask Application

Provides database operations for users, jobs, applications, search history, and user profiles
with proper error handling and Row Level Security (RLS) support.
"""

import os
import logging
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime, timedelta
from supabase import create_client, Client
from dataclasses import dataclass, asdict
from enum import Enum
import uuid
from dotenv import load_dotenv
from .user_profile_manager import UserProfileManager
from .models import JobFavorite

load_dotenv()

logger = logging.getLogger(__name__)


class ApplicationStatus(Enum):
    """Application status enumeration."""
    PENDING = "pending"
    APPLIED = "applied"
    INTERVIEWING = "interviewing"
    REJECTED = "rejected"
    ACCEPTED = "accepted"
    WITHDRAWN = "withdrawn"


class ApplicationMethod(Enum):
    """Application method enumeration."""
    MANUAL = "manual"
    AUTOMATED = "automated"
    LINKEDIN_EASY_APPLY = "linkedin_easy_apply"


@dataclass
class User:
    """User data model."""
    user_id: str
    email: str
    full_name: str
    linkedin_credentials: Optional[str] = None
    subscription_status: str = "free"
    search_preferences: Optional[Dict] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


@dataclass
class Job:
    """Job data model."""
    job_id: str
    user_id: str
    job_title: str
    company_name: str
    location: str
    salary_range: Optional[str] = None
    job_description: Optional[str] = None
    linkedin_url: Optional[str] = None
    date_posted: Optional[datetime] = None
    date_found: Optional[datetime] = None
    work_arrangement: Optional[str] = None
    experience_level: Optional[str] = None
    job_type: Optional[str] = None
    gemini_evaluation: Optional[str] = None
    gemini_score: Optional[float] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


@dataclass
class Application:
    """Application data model."""
    application_id: str
    user_id: str
    job_id: str
    application_method: ApplicationMethod
    applied_date: datetime
    application_status: ApplicationStatus
    notes: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


@dataclass
class JobSearch:
    """Job search data model."""
    search_id: str
    user_id: str
    keywords: List[str]
    location: Optional[str] = None
    filters: Optional[Dict] = None
    results_count: int = 0
    search_date: datetime = None
    created_at: Optional[datetime] = None


@dataclass
class FavoriteListing:
    """
    Represents a user's favorite job listing in the Supabase favorites table.
    
    This model matches the Supabase favorites table structure:
    - id: UUID (auto-generated by Supabase)
    - user_id: UUID
    - job_id: UUID
    - created_at: datetime (auto-generated by Supabase)
    """
    id: Optional[str] = None  # UUID, auto-generated by Supabase
    user_id: str = ""
    job_id: str = ""
    created_at: Optional[datetime] = None  # Auto-generated by Supabase
    
    def __post_init__(self) -> None:
        """Validate and set default values after initialization."""
        if not self.id:
            self.id = str(uuid.uuid4())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the favorite listing to a dictionary for storage."""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'job_id': self.job_id,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'FavoriteListing':
        """Create a favorite listing from a dictionary."""
        # Convert datetime string back to datetime object
        created_at = datetime.fromisoformat(data['created_at']) if data.get('created_at') else None
        
        return cls(
            id=data.get('id'),
            user_id=data.get('user_id', ''),
            job_id=data.get('job_id', ''),
            created_at=created_at
        )


class SupabaseManager:
    """
    Main Supabase database manager with connection pooling and error handling.
    """
    
    def __init__(self, supabase_url: str, supabase_key: str):
        """
        Initialize the Supabase database manager.
        
        Args:
            supabase_url: Supabase project URL
            supabase_key: Supabase anon key
        """
        self.supabase_url = supabase_url
        self.supabase_key = supabase_key
        
        # Initialize Supabase client
        try:
            self.client: Client = create_client(supabase_url, supabase_key)
            logger.info("Supabase database manager initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize Supabase database manager: {e}")
            raise
        
        # Initialize managers
        self.users = UserManager(self.client)
        self.jobs = JobManager(self.client)
        self.applications = ApplicationManager(self.client)
        self.searches = SearchHistoryManager(self.client)
        self.profiles = UserProfileManager(self.client)
        self.favorites = FavoriteManager(self.client)
    
    def get_applications_by_user(self, user_id):
        """Get all applications for a user (optimized for counting)"""
        try:
            response = self.client.table('applications').select(
                'job_id'  # Only select what we need
            ).eq('user_id', user_id).execute()
            
            return response.data if response.data else []
        except Exception as e:
            logger.error(f"Error getting applications for user {user_id}: {str(e)}")
            return []
        
    def get_all_jobs(self, user_id):
        """Get all jobs for a user ordered by date_found desc"""
        try:
            logger.info(f"DEBUG: get_all_jobs called for user {user_id}")
            response = self.client.table('jobs').select('*').eq(
                'user_id', user_id
            ).order('date_found', desc=True).execute()
            
            data = response.data if response.data else []
            logger.info(f"DEBUG: get_all_jobs returned {len(data)} jobs")
            
            # Enhanced debugging: Check what columns are actually returned
            if data:
                logger.info(f"DEBUG: First job from database has keys: {list(data[0].keys())}")
                logger.info(f"DEBUG: First job linkedin_url: {data[0].get('linkedin_url', 'NOT_FOUND')}")
                logger.info(f"DEBUG: First job job_url: {data[0].get('job_url', 'NOT_FOUND')}")
                logger.info(f"DEBUG: First job linkedin_job_url: {data[0].get('linkedin_job_url', 'NOT_FOUND')}")
                logger.info(f"DEBUG: First job url: {data[0].get('url', 'NOT_FOUND')}")
                
                # Check for specific job ID
                for job in data:
                    if job.get('job_id') == '79a162d8-842a-4a81-830d-6b88d207df7b':
                        logger.info(f"DEBUG: Found specific job in database:")
                        logger.info(f"DEBUG: Job ID: {job.get('job_id')}")
                        logger.info(f"DEBUG: All keys: {list(job.keys())}")
                        logger.info(f"DEBUG: linkedin_url: {job.get('linkedin_url', 'NOT_FOUND')}")
                        logger.info(f"DEBUG: job_url: {job.get('job_url', 'NOT_FOUND')}")
                        logger.info(f"DEBUG: linkedin_job_url: {job.get('linkedin_job_url', 'NOT_FOUND')}")
                        logger.info(f"DEBUG: url: {job.get('url', 'NOT_FOUND')}")
                        logger.info(f"DEBUG: Full job data: {job}")
                        break
            
            return data
        except Exception as e:
            logger.error(f"Error getting jobs for user {user_id}: {str(e)}")
            return []

    # Alternative: If you want to use raw SQL for maximum performance
    def get_jobs_with_application_counts_sql(self, user_id):
        """Get jobs with application counts using raw SQL"""
        try:
            # Use Supabase RPC if you have the function created
            response = self.client.rpc(
                'get_jobs_with_application_counts', 
                {'p_user_id': user_id}
            ).execute()
            
            return response.data if response.data else []
        except Exception as e:
            logger.error(f"Error getting jobs with counts for user {user_id}: {str(e)}")
            return []


class UserManager:
    """Manages user-related database operations."""
    
    def __init__(self, client: Client):
        self.client = client
        self.table_name = "users"
    
    def create_user(self, user_data: Dict[str, Any]) -> Tuple[bool, str, Optional[User]]:
        """
        Create a new user record.
        
        Args:
            user_data: User data dictionary
            
        Returns:
            Tuple of (success, message, user_object)
        """
        try:
            # Validate required fields
            required_fields = ['user_id', 'email', 'full_name']
            for field in required_fields:
                if field not in user_data:
                    return False, f"Missing required field: {field}", None
            
            # Check if user already exists
            existing = self.get_user_by_id(user_data['user_id'])
            if existing:
                return False, "User already exists", None
            
            # Insert user
            response = self.client.table(self.table_name).insert(user_data).execute()
            
            if response.data:
                user = User(**response.data[0])
                logger.info(f"User created successfully: {user.email}")
                return True, "User created successfully", user
            else:
                return False, "Failed to create user", None
                
        except Exception as e:
            logger.error(f"Error creating user: {e}")
            return False, f"Failed to create user: {str(e)}", None
    
    def get_user_by_id(self, user_id: str) -> Optional[User]:
        """
        Get user by ID.
        
        Args:
            user_id: User ID
            
        Returns:
            User object or None
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).execute()
            
            if response.data:
                return User(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting user by ID: {e}")
            return None
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """
        Get user by email.
        
        Args:
            email: User email
            
        Returns:
            User object or None
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("email", email).execute()
            
            if response.data:
                return User(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting user by email: {e}")
            return None
    
    def update_user(self, user_id: str, updates: Dict[str, Any]) -> Tuple[bool, str, Optional[User]]:
        """
        Update user information.
        
        Args:
            user_id: User ID
            updates: Dictionary of fields to update
            
        Returns:
            Tuple of (success, message, updated_user)
        """
        try:
            # Add updated_at timestamp
            updates['updated_at'] = datetime.utcnow().isoformat()
            
            response = self.client.table(self.table_name).update(updates).eq("user_id", user_id).execute()
            
            if response.data:
                user = User(**response.data[0])
                logger.info(f"User updated successfully: {user.email}")
                return True, "User updated successfully", user
            else:
                return False, "User not found", None
                
        except Exception as e:
            logger.error(f"Error updating user: {e}")
            return False, f"Failed to update user: {str(e)}", None
    
    def delete_user(self, user_id: str) -> Tuple[bool, str]:
        """
        Delete user (cascade delete related data).
        
        Args:
            user_id: User ID
            
        Returns:
            Tuple of (success, message)
        """
        try:
            # Delete related data first (jobs, applications, searches)
            # This will be handled by RLS policies in Supabase
            
            response = self.client.table(self.table_name).delete().eq("user_id", user_id).execute()
            
            if response.data:
                logger.info(f"User deleted successfully: {user_id}")
                return True, "User deleted successfully"
            else:
                return False, "User not found"
                
        except Exception as e:
            logger.error(f"Error deleting user: {e}")
            return False, f"Failed to delete user: {str(e)}"


class JobManager:
    """Manages job-related database operations."""
    
    def __init__(self, client: Client):
        self.client = client
        self.table_name = "jobs"
    
    def create_job(self, job_data: Dict[str, Any]) -> Tuple[bool, str, Optional[Job]]:
        """
        Create a new job record.
        
        Args:
            job_data: Job data dictionary
            
        Returns:
            Tuple of (success, message, job_object)
        """
        try:
            # Validate required fields
            required_fields = ['user_id', 'job_title', 'company_name', 'location']
            for field in required_fields:
                if field not in job_data:
                    return False, f"Missing required field: {field}", None
            
            # Generate job_id if not provided
            if 'job_id' not in job_data:
                job_data['job_id'] = str(uuid.uuid4())
            
            # Add timestamps
            if 'date_found' not in job_data:
                job_data['date_found'] = datetime.utcnow().isoformat()
            
            # Check for duplicates
            if self.is_job_duplicate(job_data['user_id'], job_data.get('linkedin_url')):
                return False, "Job already exists", None
            
            # Insert job
            response = self.client.table(self.table_name).insert(job_data).execute()
            
            if response.data:
                job = Job(**response.data[0])
                logger.info(f"Job created successfully: {job.job_title} at {job.company_name}")
                return True, "Job created successfully", job
            else:
                return False, "Failed to create job", None
                
        except Exception as e:
            logger.error(f"Error creating job: {e}")
            return False, f"Failed to create job: {str(e)}", None
    
    def get_job_by_id(self, job_id: str, user_id: str) -> Optional[Job]:
        """
        Get job by ID for specific user.
        
        Args:
            job_id: Job ID
            user_id: User ID
            
        Returns:
            Job object or None
        """
        try:
            # Try with 'id' field first (database primary key)
            response = self.client.table(self.table_name).select("*").eq("id", job_id).eq("user_id", user_id).execute()
            
            if not response.data:
                # Fallback to 'job_id' field
                response = self.client.table(self.table_name).select("*").eq("job_id", job_id).eq("user_id", user_id).execute()
            
            if response.data:
                return Job(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting job by ID: {e}")
            return None
    
    def get_user_jobs(self, user_id: str, limit: int = 100, offset: int = 0) -> List[Job]:
        """
        Get all jobs for a user.
        
        Args:
            user_id: User ID
            limit: Maximum number of jobs to return
            offset: Number of jobs to skip
            
        Returns:
            List of Job objects
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).order("date_found", desc=True).range(offset, offset + limit - 1).execute()
            
            return [Job(**job) for job in response.data]
            
        except Exception as e:
            logger.error(f"Error getting user jobs: {e}")
            return []
    
    def search_jobs(self, user_id: str, keywords: Optional[str] = None, company: Optional[str] = None, 
                   location: Optional[str] = None, limit: int = 50) -> List[Job]:
        """
        Search jobs for a user.
        
        Args:
            user_id: User ID
            keywords: Search keywords
            company: Company name filter
            location: Location filter
            limit: Maximum number of results
            
        Returns:
            List of Job objects
        """
        try:
            query = self.client.table(self.table_name).select("*").eq("user_id", user_id)
            
            if keywords:
                query = query.or_(f"job_title.ilike.%{keywords}%,job_description.ilike.%{keywords}%")
            
            if company:
                query = query.ilike("company_name", f"%{company}%")
            
            if location:
                query = query.ilike("location", f"%{location}%")
            
            response = query.order("date_found", desc=True).limit(limit).execute()
            
            return [Job(**job) for job in response.data]
            
        except Exception as e:
            logger.error(f"Error searching jobs: {e}")
            return []
    
    def update_job(self, job_id: str, user_id: str, updates: Dict[str, Any]) -> Tuple[bool, str, Optional[Job]]:
        """
        Update job information.
        
        Args:
            job_id: Job ID
            user_id: User ID
            updates: Dictionary of fields to update
            
        Returns:
            Tuple of (success, message, updated_job)
        """
        try:
            # Add updated_at timestamp
            updates['updated_at'] = datetime.utcnow().isoformat()
            
            response = self.client.table(self.table_name).update(updates).eq("job_id", job_id).eq("user_id", user_id).execute()
            
            if response.data:
                job = Job(**response.data[0])
                logger.info(f"Job updated successfully: {job.job_title}")
                return True, "Job updated successfully", job
            else:
                return False, "Job not found", None
                
        except Exception as e:
            logger.error(f"Error updating job: {e}")
            return False, f"Failed to update job: {str(e)}", None
    
    def delete_job(self, job_id: str, user_id: str) -> Tuple[bool, str]:
        """
        Delete job.
        
        Args:
            job_id: Job ID
            user_id: User ID
            
        Returns:
            Tuple of (success, message)
        """
        try:
            response = self.client.table(self.table_name).delete().eq("job_id", job_id).eq("user_id", user_id).execute()
            
            if response.data:
                logger.info(f"Job deleted successfully: {job_id}")
                return True, "Job deleted successfully"
            else:
                return False, "Job not found"
                
        except Exception as e:
            logger.error(f"Error deleting job: {e}")
            return False, f"Failed to delete job: {str(e)}"
    
    def is_job_duplicate(self, user_id: str, linkedin_url: Optional[str] = None) -> bool:
        """
        Check if job is a duplicate for the user.
        
        Args:
            user_id: User ID
            linkedin_url: Job URL
            
        Returns:
            True if duplicate exists, False otherwise
        """
        try:
            if not linkedin_url:
                return False
            
            query = self.client.table(self.table_name).select("job_id").eq("user_id", user_id).eq("linkedin_url", linkedin_url)
            response = query.execute()
            return len(response.data) > 0
            
        except Exception as e:
            logger.error(f"Error checking job duplicate: {e}")
            return False
    
    def bulk_create_jobs(self, jobs_data: List[Dict[str, Any]]) -> Tuple[bool, str, List[Job]]:
        """
        Create multiple jobs at once.
        
        Args:
            jobs_data: List of job data dictionaries
            
        Returns:
            Tuple of (success, message, created_jobs)
        """
        try:
            created_jobs = []
            
            for job_data in jobs_data:
                success, message, job = self.create_job(job_data)
                if success and job:
                    created_jobs.append(job)
            
            logger.info(f"Bulk created {len(created_jobs)} jobs")
            return True, f"Created {len(created_jobs)} jobs", created_jobs
            
        except Exception as e:
            logger.error(f"Error bulk creating jobs: {e}")
            return False, f"Failed to bulk create jobs: {str(e)}", []


class ApplicationManager:
    """Manages application-related database operations."""
    
    def __init__(self, client: Client):
        self.client = client
        self.table_name = "applications"
    
    def create_application(self, application_data: Dict[str, Any]) -> Tuple[bool, str, Optional[Application]]:
        """
        Create a new application record.
        
        Args:
            application_data: Application data dictionary
            
        Returns:
            Tuple of (success, message, application_object)
        """
        try:
            # Validate required fields
            required_fields = ['user_id', 'job_id', 'application_method', 'applied_date', 'application_status']
            for field in required_fields:
                if field not in application_data:
                    return False, f"Missing required field: {field}", None
            
            # Generate application_id if not provided
            if 'application_id' not in application_data:
                application_data['application_id'] = str(uuid.uuid4())
            
            # Convert enum values to strings
            if isinstance(application_data['application_method'], ApplicationMethod):
                application_data['application_method'] = application_data['application_method'].value
            
            if isinstance(application_data['application_status'], ApplicationStatus):
                application_data['application_status'] = application_data['application_status'].value
            
            # Check for existing application
            existing = self.get_application_by_job(application_data['user_id'], application_data['job_id'])
            if existing:
                return False, "Application already exists for this job", None
            
            # Insert application
            response = self.client.table(self.table_name).insert(application_data).execute()
            
            if response.data:
                app = Application(**response.data[0])
                logger.info(f"Application created successfully for job: {app.job_id}")
                return True, "Application created successfully", app
            else:
                return False, "Failed to create application", None
                
        except Exception as e:
            logger.error(f"Error creating application: {e}")
            return False, f"Failed to create application: {str(e)}", None
    
    def get_application_by_id(self, application_id: str, user_id: str) -> Optional[Application]:
        """
        Get application by ID for specific user.
        
        Args:
            application_id: Application ID
            user_id: User ID
            
        Returns:
            Application object or None
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("application_id", application_id).eq("user_id", user_id).execute()
            
            if response.data:
                return Application(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting application by ID: {e}")
            return None
    
    def get_application_by_job(self, user_id: str, job_id: str) -> Optional[Application]:
        """
        Get application for a specific job.
        
        Args:
            user_id: User ID
            job_id: Job ID
            
        Returns:
            Application object or None
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).eq("job_id", job_id).execute()
            
            if response.data:
                return Application(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting application by job: {e}")
            return None
    
    def get_user_applications(self, user_id: str, status: Optional[ApplicationStatus] = None, 
                            limit: int = 100, offset: int = 0) -> List[Application]:
        """
        Get all applications for a user.
        
        Args:
            user_id: User ID
            status: Filter by application status
            limit: Maximum number of applications to return
            offset: Number of applications to skip
            
        Returns:
            List of Application objects
        """
        try:
            query = self.client.table(self.table_name).select("*").eq("user_id", user_id)
            
            if status:
                query = query.eq("application_status", status.value)
            
            response = query.order("applied_date", desc=True).range(offset, offset + limit - 1).execute()
            
            return [Application(**app) for app in response.data]
            
        except Exception as e:
            logger.error(f"Error getting user applications: {e}")
            return []
    
    def update_application_status(self, application_id: str, user_id: str, 
                                status: ApplicationStatus, notes: Optional[str] = None) -> Tuple[bool, str, Optional[Application]]:
        """
        Update application status.
        
        Args:
            application_id: Application ID
            user_id: User ID
            status: New application status
            notes: Optional notes
            
        Returns:
            Tuple of (success, message, updated_application)
        """
        try:
            updates = {
                "application_status": status.value,
                "updated_at": datetime.utcnow().isoformat()
            }
            
            if notes is not None:
                updates["notes"] = notes
            
            response = self.client.table(self.table_name).update(updates).eq("application_id", application_id).eq("user_id", user_id).execute()
            
            if response.data:
                app = Application(**response.data[0])
                logger.info(f"Application status updated: {app.application_id} -> {status.value}")
                return True, "Application status updated successfully", app
            else:
                return False, "Application not found", None
                
        except Exception as e:
            logger.error(f"Error updating application status: {e}")
            return False, f"Failed to update application status: {str(e)}", None
    
    def delete_application(self, application_id: str, user_id: str) -> Tuple[bool, str]:
        """
        Delete application.
        
        Args:
            application_id: Application ID
            user_id: User ID
            
        Returns:
            Tuple of (success, message)
        """
        try:
            response = self.client.table(self.table_name).delete().eq("application_id", application_id).eq("user_id", user_id).execute()
            
            if response.data:
                logger.info(f"Application deleted successfully: {application_id}")
                return True, "Application deleted successfully"
            else:
                return False, "Application not found"
                
        except Exception as e:
            logger.error(f"Error deleting application: {e}")
            return False, f"Failed to delete application: {str(e)}"


class SearchHistoryManager:
    """Manages job search history database operations."""
    
    def __init__(self, client: Client):
        self.client = client
        self.table_name = "job_searches"
    
    def create_search(self, search_data: Dict[str, Any]) -> Tuple[bool, str, Optional[JobSearch]]:
        """
        Create a new search record.
        
        Args:
            search_data: Search data dictionary
            
        Returns:
            Tuple of (success, message, search_object)
        """
        try:
            # Validate required fields
            required_fields = ['user_id', 'keywords']
            for field in required_fields:
                if field not in search_data:
                    return False, f"Missing required field: {field}", None
            
            # Generate search_id if not provided
            if 'search_id' not in search_data:
                search_data['search_id'] = str(uuid.uuid4())
            
            # Add search date if not provided
            if 'search_date' not in search_data:
                search_data['search_date'] = datetime.utcnow().isoformat()
            
            # Insert search
            response = self.client.table(self.table_name).insert(search_data).execute()
            
            if response.data:
                search = JobSearch(**response.data[0])
                logger.info(f"Search created successfully: {search.keywords}")
                return True, "Search created successfully", search
            else:
                return False, "Failed to create search", None
                
        except Exception as e:
            logger.error(f"Error creating search: {e}")
            return False, f"Failed to create search: {str(e)}", None
    
    def get_user_searches(self, user_id: str, limit: int = 50, offset: int = 0) -> List[JobSearch]:
        """
        Get search history for a user.
        
        Args:
            user_id: User ID
            limit: Maximum number of searches to return
            offset: Number of searches to skip
            
        Returns:
            List of JobSearch objects
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).order("search_date", desc=True).range(offset, offset + limit - 1).execute()
            
            return [JobSearch(**search) for search in response.data]
            
        except Exception as e:
            logger.error(f"Error getting user searches: {e}")
            return []
    
    def get_search_by_id(self, search_id: str, user_id: str) -> Optional[JobSearch]:
        """
        Get search by ID for specific user.
        
        Args:
            search_id: Search ID
            user_id: User ID
            
        Returns:
            JobSearch object or None
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("search_id", search_id).eq("user_id", user_id).execute()
            
            if response.data:
                return JobSearch(**response.data[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting search by ID: {e}")
            return None
    
    def update_search_results(self, search_id: str, user_id: str, results_count: int) -> Tuple[bool, str, Optional[JobSearch]]:
        """
        Update search results count.
        
        Args:
            search_id: Search ID
            user_id: User ID
            results_count: Number of results found
            
        Returns:
            Tuple of (success, message, updated_search)
        """
        try:
            updates = {
                "results_count": results_count
            }
            
            response = self.client.table(self.table_name).update(updates).eq("search_id", search_id).eq("user_id", user_id).execute()
            
            if response.data:
                search = JobSearch(**response.data[0])
                logger.info(f"Search results updated: {search_id} -> {results_count} results")
                return True, "Search results updated successfully", search
            else:
                return False, "Search not found", None
                
        except Exception as e:
            logger.error(f"Error updating search results: {e}")
            return False, f"Failed to update search results: {str(e)}", None
    
    def delete_search(self, search_id: str, user_id: str) -> Tuple[bool, str]:
        """
        Delete search record.
        
        Args:
            search_id: Search ID
            user_id: User ID
            
        Returns:
            Tuple of (success, message)
        """
        try:
            response = self.client.table(self.table_name).delete().eq("search_id", search_id).eq("user_id", user_id).execute()
            
            if response.data:
                logger.info(f"Search deleted successfully: {search_id}")
                return True, "Search deleted successfully"
            else:
                return False, "Search not found"
                
        except Exception as e:
            logger.error(f"Error deleting search: {e}")
            return False, f"Failed to delete search: {str(e)}"


class FavoriteManager:
    """Manager for favorites table operations."""
    
    def __init__(self, client: Client):
        """Initialize the favorite manager with Supabase client."""
        self.client = client
        self.table_name = "favorites"
    
    def add_favorite(self, favorite_data: FavoriteListing) -> FavoriteListing:
        """
        Add a job to user's favorites.
        
        Args:
            favorite_data: FavoriteListing object containing user_id and job_id
            
        Returns:
            FavoriteListing object with id and created_at from Supabase
            
        Raises:
            Exception: If database insertion fails
        """
        try:
            # Prepare data for insertion (exclude id and created_at as they're auto-generated)
            insert_data = {
                "user_id": favorite_data.user_id,
                "job_id": favorite_data.job_id
            }
            
            response = self.client.table(self.table_name).insert(insert_data).execute()
            
            if response.data:
                # Return the created favorite with all fields from Supabase
                created_favorite = FavoriteListing.from_dict(response.data[0])
                logger.info(f"Favorite added successfully: user_id={favorite_data.user_id}, job_id={favorite_data.job_id}")
                return created_favorite
            else:
                raise Exception("No data returned from insert operation")
                
        except Exception as e:
            logger.error(f"Error adding favorite: {e}")
            raise Exception(f"Failed to add favorite: {str(e)}")
    
    def get_user_favorites(self, user_id: str) -> List[FavoriteListing]:
        """
        Get all favorited jobs for a user.
        
        Args:
            user_id: User ID to get favorites for
            
        Returns:
            List of FavoriteListing objects
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).order("created_at", desc=True).execute()
            
            favorites = []
            for favorite_data in response.data:
                favorite = FavoriteListing.from_dict(favorite_data)
                favorites.append(favorite)
            
            logger.info(f"Retrieved {len(favorites)} favorites for user: {user_id}")
            return favorites
            
        except Exception as e:
            logger.error(f"Error getting user favorites: {e}")
            return []
    
    def remove_favorite(self, favorite_id: str) -> bool:
        """
        Remove a favorite entry by its id.
        
        Args:
            favorite_id: ID of the favorite entry to remove
            
        Returns:
            True on successful deletion, False otherwise
        """
        try:
            response = self.client.table(self.table_name).delete().eq("id", favorite_id).execute()
            
            if response.data:
                logger.info(f"Favorite removed successfully: {favorite_id}")
                return True
            else:
                logger.warning(f"Favorite not found for deletion: {favorite_id}")
                return False
                
        except Exception as e:
            logger.error(f"Error removing favorite: {e}")
            return False
    
    def is_job_favorited(self, user_id: str, job_id: str) -> bool:
        """
        Check if a specific job has already been favorited by a user.
        
        Args:
            user_id: User ID
            job_id: Job ID
            
        Returns:
            True if the job is favorited, False otherwise
        """
        try:
            response = self.client.table(self.table_name).select("id").eq("user_id", user_id).eq("job_id", job_id).execute()
            
            is_favorited = len(response.data) > 0
            logger.debug(f"Job favorited check: user_id={user_id}, job_id={job_id}, result={is_favorited}")
            return is_favorited
            
        except Exception as e:
            logger.error(f"Error checking if job is favorited: {e}")
            return False
    
    def get_favorite_by_job(self, user_id: str, job_id: str) -> Optional[FavoriteListing]:
        """
        Get a specific favorite entry by user_id and job_id.
        
        Args:
            user_id: User ID
            job_id: Job ID
            
        Returns:
            FavoriteListing object or None if not found
        """
        try:
            response = self.client.table(self.table_name).select("*").eq("user_id", user_id).eq("job_id", job_id).execute()
            
            if response.data:
                favorite = FavoriteListing.from_dict(response.data[0])
                return favorite
            return None
            
        except Exception as e:
            logger.error(f"Error getting favorite by job: {e}")
            return None
    
    def remove_favorite_by_job(self, user_id: str, job_id: str) -> bool:
        """
        Remove a favorite entry by user_id and job_id.
        
        Args:
            user_id: User ID
            job_id: Job ID
            
        Returns:
            True on successful deletion, False otherwise
        """
        try:
            response = self.client.table(self.table_name).delete().eq("user_id", user_id).eq("job_id", job_id).execute()
            
            if response.data:
                logger.info(f"Favorite removed by job successfully: user_id={user_id}, job_id={job_id}")
                return True
            else:
                logger.warning(f"Favorite not found for deletion: user_id={user_id}, job_id={job_id}")
                return False
                
        except Exception as e:
            logger.error(f"Error removing favorite by job: {e}")
            return False 